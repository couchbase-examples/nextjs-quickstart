= Quickstart in Couchbase with Node JS and Express

:page-slug: tutorial-nextjs
:page-title: Using Next.js with Couchbase
:page-category: tutorials
:page-desc: Build a basic Next.js front-end and back-end app with Couchbase
:page-tags: Tutorial, Node.js
:page-order: 00004
:page-estimate: 60 min

[.title]
{page-title}

image::https://da-demo-images.s3.amazonaws.com/runItNow_outline.png?couchbase-example=nodejs-quickstart-repo&source=devPortal[link="https://gitpod.io/#https://github.com/couchbase-examples/tutorial-nextjs", width=150]

[.desc]
{page-desc}

[abstract]
In this article, you will learn how to use Next.js to connect to a Couchbase cluster to create, read, update, and delete documents and how to write simple parametrized N1QL queries. You will also build a basic front-end application to interact with your data.

We will be using the latest version of Couchbase (version 7) that enables scopes and collections.

== Prerequisites

To run this prebuilt project, you will need:

- Couchbase 7 Installed
- NodeJS & NPM (v12+)
- NextJS
- Code Editor

== What We'll Cover
Bootstrapping a new Next.js app using the 'with-couchbase' example, building out a simple REST API using the API framework built into Next.js and the, link:https://docs.couchbase.com/nodejs-sdk/current/hello-world/start-using-sdk.html[Node.js SDK for Couchbase], version 3.x with the following endpoints:

- <<post-profile>> – Create a new user profile
- <<getbykey-profile>> – Get a specific profile
- <<put-profile>> – Update a profile
- <<delete-profile>> – Delete a profile
- <<get-profiles>> – Get all profiles matching First or Last Name

We'll also build out a basic front-end application with Next.js to interact with the endpoints mentioned above.

== Source Code
The completed source code from this tutorial can be cloned with the following command:
```sh
git clone https://github.com/couchbase-examples/tutorial-nextjs
```

== Set up and Run The Application
We'll start by bootstrapping a new Next.js project using the 'with-couchbase' example:

```sh
npx create-next-app --example with-couchbase with-couchbase-app

# or

yarn create next-app --example with-couchbase with-couchbase-app
```

Install required dependencies and run:
```sh
npm install
npm run dev

# or

yarn install
yarn dev
```


*After installation of Couchbase 7, and if it is running on localhost (http://127.0.0.1:8091) we can create a bucket named `user_profile` and a collection named `profile`. You can do this manually by accessing the Couchbase console.


// or if you've cloned the completed project running the following command will handle this step:

// TODO: add init-db for testing
//```sh
//npm run init-db
//```
To set environment variables, copy the `env.local.example` file in this directory to `.env.local`:

```bash
cp .env.local.example .env.local
```

Set each variable on `.env.local`:

- `COUCHBASE_USERNAME` - The username of an authorized user on your Couchbase instance
- `COUCHBASE_PASSWORD` - The corresponding password for the user specified above
- `COUCHBASE_ENDPOINT` - The endpoint to connect to. Use `localhost` for a local instance of Couchbase, or Wide Area Network address for a cloud instance (formatted like`<xxxxx>.dp.cloud.couchbase.com`)
- `TEST_BUCKET_NAME` - The bucket you'd like to connect to. Set this to `user_profiles` for this tutorial.
- `IS_CLOUD_INSTANCE` - `true` if you are trying to connect to an instance of Couchbase Cloud, `false` otherwise.

In order to interact with your Couchbase instance, you'll need to set up and configure the database.


If everything is set up properly, you should be able to navigate to localhost:3000 to see a message confirming succesful connection to Couchbase. For troubleshooting and additional setup instructions please refer to the `NextJS_Example_README.md` included in the with-couchbase starter.


== Document Structure

We will be setting up a REST API to manage some profile documents. Our profile document will have an auto-generated UUID for its key, first and last name of the user, an email, and hashed password. For this demo we will store all profile information in just one document in a collection named `profile`:

```json
{
  "pid": "b181551f-071a-4539-96a5-8a3fe8717faf",
  "firstName": "John",
  "lastName": "Wick",
  "email": "johnwick@couchbase.com",
  "password": "$2a$10$tZ23pbQ1sCX4BknkDIN6NekNo1p/Xo.Vfsttm.USwWYbLAAspeWsC"
}
```

== Let's Review the Starter Code
The starter application has two main files, `util/couchbase.js` and `pages/index.js`. We'll add a few files to fill out our application further, but first let's review each of these.

**`util/couchbase.js`:**

The `couchbase.js` file contains all logic for connecting to the database. It validates environment variables and checks for an open connection before creating and returning cluster, bucket, and collection objects. Our other files can import the `connectToDatabase()` function to gain access to each of these objects.

```js
export async function connectToDatabase() {
  const cluster = await createCouchbaseCluster();

  const bucket = cluster.bucket(TEST_BUCKET_NAME);
  const collection = bucket.defaultCollection();

  let dbConnection = {
    cluster,
    bucket,
    profileCollection: collection
  }

  return dbConnection;
}
```

**`pages/index.js`:**

The index page renders content for our homepage and includes a `getServerSideProps()` function that is automatically run on each page load and injects props into the React component rendered by the index page.

```js
export async function getServerSideProps(context) {
  let connection = await connectToDatabase();
  const {cluster, bucket, profileCollection} = connection;
  // checks connection
  // runs simple query
  return {
    props: {isConnected, rows},
  }
}
```
The logic for checking the connection and running a simple query can be viewed in the file, but aren't necessary for this project. As long as your connection is working, you are ready to move onto the next steps and start coding!


== Ensure Primary Index Exists

The first time the app is run, we create two primary indexes, one for our user_profile bucket and another for our `profile` collection. The collection index is used by the `"/profile"` GET endpoint that utilizes a N1QL query to search the database for profile documents where `firstName` or `lastName` match the search value. The bucket index can be used in the case that any documents are added to the bucket's default collection or manually from the Couchbase Web UI.

Add this function to `couchbase.js` and call it right after you call `createCouchbaseCluster()` (passing it the cluster you just created):

```js
const ensureIndexes = async(cluster) => {
  try {
    const bucketIndex = `CREATE PRIMARY INDEX ON ${TEST_BUCKET_NAME}`
    const collectionIndex = `CREATE PRIMARY INDEX ON default:${TEST_BUCKET_NAME}._default.profile;`
    await cluster.query(bucketIndex)
    await cluster.query(collectionIndex)
    console.log(`Index Creation: SUCCESS`)
  } catch (err) {
    if (err instanceof couchbase.IndexExistsError) {
      console.info('Index Creation: Indexes Already Exists')
    } else {
      console.error(err)
    }
  }
}
```

Now we can move onto reviewing each of the individual endpoints. Next.js has a built-in API framework that we'll leverage to interact with our Couchbase data source.

== API Setup
We'll start by adding an `api/` directory inside the `pages/` directory. Any file within this directory will be mapped to an API endpoint, so we'll also create a file called `user.js` and add a handler function. This function will handle ALL request types to this endpoint, so we'll also need to check the request type and handle it accordingly. We'll also need to connect to the database and parse the body if it exists.
```js
export default async function handler(req, res) {
  const {cluster, bucket, profileCollection} = await connectToDatabase();
  let body = !!req.body ? JSON.parse(req.body) : null;
  if (req.method === 'POST') {
    // handle POST request
  } else if (req.method === 'PUT') {
    // handle PUT request
  } else if (req.method === 'GET') {
    // handle GET request (search)
  } else if (req.method === 'DELETE') {
    // handle DELETE request
  }
}
```

Next, we'll fill in logic to handle each of the request types.

[[post-profile]]
== POST a Profile

After checking that the body contains the proper fields, we create a profile document using the SDK `.insert()` method using the `profileCollection`. Note that you will need to install bcryptjs (to hash passwords) and uid (to generate unique IDs) with npm or yarn and import them in `user.js`.

```js
if (!body.email || !body.pass) {
      return res.status(400).send({
        "message": `${!body.email ? 'email ' : ''}${
            (!body.email && !body.pass)
                ? 'and pass are required' : (body.email && !body.pass)
                ? 'pass is required' : 'is required'
        }`
      })
    }

    const id = v4();
    const profile = {
      pid: id,
      ...body,
      pass: bcrypt.hashSync(body.pass, 10)
    }

    await collection.insert(profile.pid, profile)
        .then((result) => {
          res.send(result);
        })
        .catch((e) => {
          res.status(500).send({
            "message": `Profile Insert Failed: ${e.message}`
          })
        })
```

Let’s break this code down.

First, we check that both an email and password exist and then create a `profile` object based on the data that was sent in the request. The `pid` that we’re saving into the account object is a unique key.

After we check for required body parameters, we create an async call to the `profileCollection` using the `insert` method and then return the document saved and the result all as part of the same object back to the user. We utilize the spread operator again to make this simple. `insert` is a basic key-value operation.

Next, lets add a simple front-end form to create user profiles. On the `index.js` page, remove all markup between the <main> tags and add the following form:
```html
<form onSubmit={handleProfilePost}>
    <input type="text" placeholder="First Name" name="firstName"/>
    <input type="text" placeholder="Last Name" name="lastName"/>
    <input type="email" placeholder="Email" name="email"/>
    <input type="password" placeholder="Password" name="password"/>
    <button type="submit">Post Profile</button>
</form>
```

We'll handle this request in a function on `index.js` inside `Home()`:
```js
const handleProfilePost = async (event) => {
    event.preventDefault();

    await fetch("http://localhost:3000/api/user", {
        method: 'POST',
        body: JSON.stringify({
            firstName: event.target.firstName.value,
            lastName: event.target.lastName.value,
            email: event.target.email.value,
            pass: event.target.password.value,
        })
    })
}
```

[[getbykey-profile]]
== GET a Profile by Key
Although the API framework baked into Next.js is highly powerful, Next is ALSO capable of fetching data from the database using the `getServerSideProps()` function in `index.js`. We'll fetch a profile by key using this method to demonstrate the versatility of Next.js.

Add the following function to the bototm of `index.js` to retrieve a Profile by Profile ID using the SDK `.get()` method` using the `profileCollection`.

```js
async function getProfileByKey(collection, key) {
  try {
    let res = await collection.get(key);
    return res.content;
  } catch (err) {
    return err;
  }
}
```

We only need the profile ID from the user to retrieve a particular profile document using a basic key-value operation. We can catch the error if the key-value operation fails and return an error message.

You can now call this function from `getServerSideProps()` and simply inject the return value into the props:
```js
  let profile = JSON.parse(JSON.stringify(await getProfileByKey(collection, '<ADD AN EXISTING PID HERE>')));

  return {
    props: {isConnected, profile },
  }
```
Note that we'll stringify then re-parse the data to avoid any issues with JSON serialization. This is just a quirk of Next.js that can sometimes cause a bug, so it's better to ensure proper serialization.

To display the user we've fetched, we'll also add a custom React component. To accomplish this, create a new directory outside of `pages/` and call it `components`. Within `components/` add a `UserCard.js` file for the following component:
```js
export const UserCard = (props) => {
  return (
      <div style={{marginRight: '10px', marginLeft: '10px', border: '1px solid #8f8f8f', borderRadius: '10px', padding: '10px'}}>
        <p><strong>{props.firstName}</strong> {props.lastName}</p>
        <p>{props.email}</p>
        <em>{!!props.pid && 'PID: ' + props.pid}</em>
      </div>
  );
}
```

Now we can go back to `index.js` and add the following markup to display the user we've fetched:
```html
<UserCard firstName={profile.firstName} lastName={profile.lastName} email={profile.email} pid={profile.pid} />
```

Once we can see the profile, lets add logic to edit it.

[[put-profile]]
== PUT Profile

Update a Profile by Profile ID by using the SDK `.upsert()` method on the `profileCollection`. We'll add the following code to our `user.js` file to handle PUT requests:

```js
  try {
      await profileCollection.get(req.query.pid)
          .then(async (result) => {
            /* Create a New Document with new values,
              if they are not passed from request, use existing values */
            const newDoc = {
              pid: result.content.pid,
              firstName: body.firstName ? body.firstName : result.content.firstName,
              lastName: body.lastName ? body.lastName : result.content.lastName,
              email: body.email ? body.email : result.content.email,
              pass: body.pass ? bcrypt.hashSync(body.pass, 10) : result.content.pass,
            }

            /* Persist updates with new doc */
            await profileCollection.upsert(req.query.pid, newDoc)
                .then((result) => res.send({ ...newDoc, ...result }))
                .catch((e) => res.status(500).send(e))
          })
          .catch((e) => res.status(500).send({
            "message": `Profile Not Found, cannot update: ${e.message}`
          }))
    } catch (e) {
      console.error(e)
    }
```

We don't need to specify the `pid` as it already exists, so when we create the profile document, we just need the profile information (`firstName`, `lastName`, `email`, and `password`). The user may only be changing one or many fields in the document so we first retrieve the existing document and check for differences and only update the fields needed to be changed.

We first look up the existing document and make sure it exists, if it does not, return a 500 level error code and message: "Cannot update: document not found".

Then, all changed fields in the document get replaced except for the document key and the `pid` field.

Next, we replace the existing fields if we have a value from the HTTP Request (`req.body.whatever`). If we do not have a value in the request for a specific field, we simply reuse the existing document's `result.value.whatever.

Finally, we create an async call to the `profileCollection` using the `upsert` method and then return the document saved and the result just as we did in the previous endpoint.

Let's add another front-end form to enable editing:
```html
<form onSubmit={handleProfilePut}>
    <input type="text" placeholder="PID to Update" name="pid"/>
    <input type="text" placeholder="New First Name" name="firstName"/>
    <input type="text" placeholder="New Last Name" name="lastName"/>
    <input type="email" placeholder="New Email" name="email"/>
    <input type="password" placeholder="New Password" name="password"/>
    <button type="submit">Update Profile</button>
</form>
```

We can handle edits with the following function:
```js
const handleProfilePut = async (event) => {
  await fetch(`http://localhost:3000/api/user?pid=${event.target.pid.value}`, {
    method: 'PUT',
    body: JSON.stringify({
      firstName: event.target.firstName.value,
      lastName: event.target.lastName.value,
      email: event.target.email.value,
      pass: event.target.password.value,
    })
  })
}
```

By pasting the PID into the field and filling in any of the form fields in the edit form, you'll be able to edit the document of the PID specified.

[[delete-profile]]
== DELETE Profile
To delete profiles, we'll first need to update our `UserCard` with a delete button:
```js
export const UserCard = (props) => {
  const handleDeletion = async (event) => {
    await fetch(`http://localhost:3000/api/user?pid=${props.pid}`, {
      method: 'DELETE',
    }).then(async (data) => {
      console.log(data);
    })
  }
  return (
      <div style={{marginRight: '10px', marginLeft: '10px', border: '1px solid #8f8f8f', borderRadius: '10px', padding: '10px'}}>
        <p><strong>{props.firstName}</strong> {props.lastName}</p>
        <p>{props.email}</p>
        <em>{!!props.pid && 'PID: ' + props.pid}</em>
        <br/>
        <button onClick={handleDeletion}>Delete</button>
      </div>
  );
}
```

Next, we'll add the following to `user.js` to handle DELETE requests. Delete Profile by Profile ID by using the SDK `.delete()` method on the `profileCollection`.

```js
try {
      await profileCollection.remove(req.query.pid)
          .then((result) => {
            res.status(200).send("Successfully Deleted: " + req.query.pid)
          })
          .catch((error) => res.status(500).send({
            "message": `Profile Not Found, cannot delete: ${error.message}`
          }))
    } catch (e) {
      console.error(e)
    }
```

We only need the profile ID from the user to delete using a basic key-value operation.

Now you'll see a 'Delete' button on the user profile we've fetched via a hard-coded id in `getServerSideProps()`. To avoid any errors that may stem from the deletion of this document, let's just comment that logic out. We're going to add a more robust 'GET' route in the next step.
```js
  // let profile = JSON.parse(JSON.stringify(await getProfileByKey(profileCollection, '1cfaaa82-e63e-4207-addf-f023763d0374')));

  return {
    props: {isConnected, /* profile */ },
  }
```
Note that you must also remove/comment out the UserCard markup for this profile.

[[get-profiles]]
== GET Profiles
Earlier, we fetched a singular profile by its key. In this step, we'll add logic to search through all profiles and return those that match a search string. Get user profiles using the `cluster.query()` method in the SDK and results are returned based on firstName or lastName with support to paginate results. Add the following to handle GET requests in `user.js`.

```js
try {
  const options = {
    parameters: {
      SKIP: Number(req.query.skip || 0),
      LIMIT: Number(req.query.limit || 5),
      SEARCH: req.query.search ? `%${req.query.search.toLowerCase()}%` : null
    }
  }

  const query = `
  SELECT p.*
  FROM ${process.env.TEST_BUCKET_NAME}._default.profile p
  WHERE lower(p.firstName) LIKE $SEARCH OR lower(p.lastName) LIKE $SEARCH
  LIMIT $LIMIT OFFSET $SKIP;
`
  await cluster.query(query, options)
      .then((result) => res.send(result.rows))
      .catch((error) => res.status(500).send({
        "message": `Query failed: ${error.message}`
      }))
} catch (e) {
  console.error(e)
}
```

This endpoint is different from the others as it makes a N1QL query rather than a key-value operation. This involves additional overhead because the query engine is involved. Remember that the `profileCollection` index (primary) was set up specifically to enable this endpoint.

Our `req.body` has three query params: `skip`, `limit`, and `search`.

We also have default values set up in case they are not provided, `0` for skip or `5` for limit.

Then, we build our N1QL query using the parameters we just created.

Finally, we pass that `query` and the `options` to the `cluster.query()` method and return the result.

Take notice of the N1QL syntax format and how it targets `bucket`.`scope`.`collection`.

Let's add yet another form with a search field, and a flexbox to display results to enable easy search and retrieval of multiple profiles.

```html
<form onSubmit={handleProfileSearch}>
    <input type="text" placeholder="Search String" name="searchString"/>
    <button type="submit">Search</button>
</form>

<h4>Profile Search Results:</h4>
<div style={{ display: "flex" }}>
    {searchResults !== null && searchResults.map((userProfile) => {
      console.log(userProfile);
      return (
          <UserCard firstName={userProfile.firstName} lastName={userProfile.lastName} email={userProfile.email} pid={userProfile.pid} allowDelete={true}/>
      )
    })
    }
</div>
```

== Conclusion

